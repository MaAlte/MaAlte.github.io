<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Services</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <header class="top-bar">
    <img src="img/BlackHoleBTC-DOLLAR.jpg" alt="Logo" class="logo" />
    <div class="site-title">MaAlte81</div>
  </header>

  <div class="glass-container">
    <h1>Services</h1>

    <div class="content">
      <p>Hier findest du eine √úbersicht meiner aktuellen Projekte, Tools und technischen Services. Inhalte folgen bald.</p>
    </div>

    <nav>
      <a href="index.html" data-direction="left">Home</a>
      <a href="services.html" data-direction="left">Services</a>
      <a href="kontakt.html" data-direction="right">Kontakt</a>
      <a href="impressum.html" data-direction="right">Impressum</a>
    </nav>

    <div class="page-transition" id="page-transition"></div>
  </div>

  <footer id="last-modified"></footer>

  <!-- Seitenstart-Animation: in jede Seite -->
  <script>
  function handlePageEnter() {
    const overlay = document.getElementById('page-transition');
    const container = document.querySelector('.glass-container');
    const direction = sessionStorage.getItem('transitionDirection');

    if (sessionStorage.getItem('transitioning') === 'true') {
      // Overlay ausblenden (falls noch aktiv)
      overlay?.classList.remove('active');

      // Setze passende enter-Klasse abh√§ngig von Richtung
      if (direction === 'left') {
        container?.classList.add('page-enter-left');
      } else {
        container?.classList.add('page-enter-right');
      }

      // Entferne rotate-Klassen erst nach der enter-Animation
      setTimeout(() => {
        container?.classList.remove('rotate-left', 'rotate-right');
        sessionStorage.removeItem('transitioning');
        sessionStorage.removeItem('transitionDirection');
      }, 700); // passt zu deinen CSS-Durations
    }
  }

  window.addEventListener('DOMContentLoaded', handlePageEnter);
  window.addEventListener('pageshow', handlePageEnter);
  </script>

  <!-- üß≠ Robust: Navigation + Rotation + Overlay mit Repaint + transitionend + Fallback -->
  <script>
  (function () {
    const container = document.querySelector('.glass-container');
    const navLinks = document.querySelectorAll('nav a');
    const transitionOverlay = document.getElementById('page-transition');

    if (!container || !transitionOverlay || navLinks.length === 0) return;

    let navigating = false; // sch√ºtzt vor Mehrfachausl√∂sung

    // Utility: force reflow
    function forceReflow(el) {
      void el.offsetWidth;
    }

    // Start transition sequence und navigiere, wenn Overlay-Transition beendet oder Fallback l√§uft
    function startTransitionAndNavigate(href, direction) {
      if (navigating) return;
      navigating = true;

      const rotateClass = `rotate-${direction}`;

      // 1) Entferne vorherige Klassen (sicherstellen, dass Neu-Setzen wirkt)
      container.classList.remove('rotate-left', 'rotate-right', 'page-enter-left', 'page-enter-right', 'page-enter');
      transitionOverlay.classList.remove('active');

      // 2) Erzwinge Reflow, damit Entfernen gerendert wird
      forceReflow(container);
      forceReflow(transitionOverlay);

      // 3) Jetzt erst Klassen setzen, Overlay aktivieren
      container.classList.add(rotateClass);
      transitionOverlay.classList.add('active');

      // 4) Markieren und Richtung speichern f√ºr die eingehende Seite
      sessionStorage.setItem('transitioning', 'true');
      sessionStorage.setItem('transitionDirection', direction);

      // 5) Einmaliger transitionend-Handler auf dem Overlay
      const onEnd = (ev) => {
        // optional: pr√ºfe propertyName wenn du mehrere Transitionen hast
        // if (ev.propertyName !== 'opacity' && ev.propertyName !== 'transform') return;
        cleanupAndNavigate();
      };

      // Fallback nach maximal 1s (falls transitionend nicht feuert)
      const fallback = setTimeout(cleanupAndNavigate, 1000);

      function cleanupAndNavigate() {
        transitionOverlay.removeEventListener('transitionend', onEnd);
        clearTimeout(fallback);
        // kleine Verz√∂gerung vor dem eigentlichen Location-Wechsel, damit der browser final rendern kann
        requestAnimationFrame(() => {
          setTimeout(() => {
            window.location.href = href;
          }, 20);
        });
      }

      transitionOverlay.addEventListener('transitionend', onEnd, { once: true });

      // Safety: falls overlay hat keine transition (dev-Fehler), trigger fallback sofort
      // (keine weitere Aktion erforderlich hier)
    }

    // Attach handler an alle Links
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        // interne anchor- oder externe link-behandlung: nur eigene htmls
        const href = link.getAttribute('href');
        if (!href) return;
        // Wenn Link auf dieselbe Seite zeigt, verhindere unn√∂tigen reload
        if (href === location.pathname.split('/').pop() || href === window.location.pathname) {
          // erlauben normalem Verhalten (kein Seitenwechsel) oder einfach nichts tun
          // wir verhindern reload, damit page-enter/exit nicht st√∂ren
          e.preventDefault();
          return;
        }

        e.preventDefault();

        // Richtungswert default 'right' ‚Äî nutze data-direction wenn vorhanden
        const direction = link.dataset.direction || 'right';

        startTransitionAndNavigate(href, direction);
      });
    });

  })();
  </script>

</body>
</html>
