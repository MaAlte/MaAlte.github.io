<!DOCTYPE html>
<html lang="de">
<head>
  <!-- üß† Meta & Styles -->
  <meta charset="UTF-8" /><link href="https://fonts.googleapis.com/css2?family=Allerta+Stencil&display=swap" rel="stylesheet" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="lightning" content="lnurlp:hiddenpaper53@getalby.com" />
  <title>Willkommen</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <!-- üß± Top-Bar mit Logo und Titel -->
  <header class="top-bar">
    <img src="img/BlackHoleBTC-DOLLAR.jpg" alt="Logo" class="logo" />
    <div class="site-title">MaAlte81</div>
  </header>

  <!-- üßä Hauptcontainer mit Inhalt und Navigation -->
  <div class="glass-container">
    <h1>Willkommen auf meiner Seite :-)</h1>

    <!-- üì∞ News-Slider -->
    <div class="news-container content">
      <div class="arrow" id="prev-news">&#10094;</div>
      <div class="news-content" id="news-content"></div>
      <div class="arrow" id="next-news">&#10095;</div>
    </div>

    <!-- üß≠ Navigation -->
    <nav>
      <a href="index.html" data-direction="left">Home</a>
      <a href="services.html" data-direction="right">Services</a>
      <a href="kontakt.html" data-direction="right">Kontakt</a>
      <a href="impressum.html" data-direction="right">Impressum</a>
    </nav>

    <!-- üîÑ Seitenwechsel-Overlay -->
    <div class="page-transition" id="page-transition"></div>
    
    <!-- üìÖ Footer mit √Ñnderungsdatum -->
    <footer id="last-modified"></footer>
  </div>



  <!-- Seitenstart-Animation: in jede Seite -->
  <script>
  function handlePageEnter() {
    const overlay = document.getElementById('page-transition');
    const container = document.querySelector('.glass-container');
    const direction = sessionStorage.getItem('transitionDirection');

    if (sessionStorage.getItem('transitioning') === 'true') {
      // Overlay ausblenden (falls noch aktiv)
      overlay?.classList.remove('active');

      // Setze passende enter-Klasse abh√§ngig von Richtung
      if (direction === 'left') {
        container?.classList.add('page-enter-left');
      } else {
        container?.classList.add('page-enter-right');
      }

      // Entferne rotate-Klassen erst nach der enter-Animation
      setTimeout(() => {
        container?.classList.remove('rotate-left', 'rotate-right');
        sessionStorage.removeItem('transitioning');
        sessionStorage.removeItem('transitionDirection');
      }, 700); // passt zu deinen CSS-Durations
    }
  }

  window.addEventListener('DOMContentLoaded', handlePageEnter);
  window.addEventListener('pageshow', handlePageEnter);
  </script>

  <!-- üìÖ Letzte √Ñnderung anzeigen -->
  <script>
    document.getElementById('last-modified').textContent =
      'Letzte √Ñnderung: ' + document.lastModified;
  </script>
  
  <!-- üß≠ Robust: Navigation + Rotation + Overlay mit Repaint + transitionend + Fallback -->
  <script>
  (function () {
    const container = document.querySelector('.glass-container');
    const navLinks = document.querySelectorAll('nav a');
    const transitionOverlay = document.getElementById('page-transition');

    if (!container || !transitionOverlay || navLinks.length === 0) return;

    let navigating = false; // sch√ºtzt vor Mehrfachausl√∂sung

    // Utility: force reflow
    function forceReflow(el) {
      void el.offsetWidth;
    }

    // Start transition sequence und navigiere, wenn Overlay-Transition beendet oder Fallback l√§uft
    function startTransitionAndNavigate(href, direction) {
      if (navigating) return;
      navigating = true;

      const rotateClass = `rotate-${direction}`;

      // 1) Entferne vorherige Klassen (sicherstellen, dass Neu-Setzen wirkt)
      container.classList.remove('rotate-left', 'rotate-right', 'page-enter-left', 'page-enter-right', 'page-enter');
      transitionOverlay.classList.remove('active');

      // 2) Erzwinge Reflow, damit Entfernen gerendert wird
      forceReflow(container);
      forceReflow(transitionOverlay);

      // 3) Jetzt erst Klassen setzen, Overlay aktivieren
      container.classList.add(rotateClass);
      transitionOverlay.classList.add('active');

      // 4) Markieren und Richtung speichern f√ºr die eingehende Seite
      sessionStorage.setItem('transitioning', 'true');
      sessionStorage.setItem('transitionDirection', direction);

      // 5) Einmaliger transitionend-Handler auf dem Overlay
      const onEnd = (ev) => {
        // optional: pr√ºfe propertyName wenn du mehrere Transitionen hast
        // if (ev.propertyName !== 'opacity' && ev.propertyName !== 'transform') return;
        cleanupAndNavigate();
      };

      // Fallback nach maximal 1s (falls transitionend nicht feuert)
      const fallback = setTimeout(cleanupAndNavigate, 1000);

      function cleanupAndNavigate() {
        transitionOverlay.removeEventListener('transitionend', onEnd);
        clearTimeout(fallback);
        // kleine Verz√∂gerung vor dem eigentlichen Location-Wechsel, damit der browser final rendern kann
        requestAnimationFrame(() => {
          setTimeout(() => {
            window.location.href = href;
          }, 20);
        });
      }

      transitionOverlay.addEventListener('transitionend', onEnd, { once: true });

      // Safety: falls overlay hat keine transition (dev-Fehler), trigger fallback sofort
      // (keine weitere Aktion erforderlich hier)
    }

    // Attach handler an alle Links
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        // interne anchor- oder externe link-behandlung: nur eigene htmls
        const href = link.getAttribute('href');
        if (!href) return;
        // Wenn Link auf dieselbe Seite zeigt, verhindere unn√∂tigen reload
        if (href === location.pathname.split('/').pop() || href === window.location.pathname) {
          // erlauben normalem Verhalten (kein Seitenwechsel) oder einfach nichts tun
          // wir verhindern reload, damit page-enter/exit nicht st√∂ren
          e.preventDefault();
          return;
        }

        e.preventDefault();

        // Richtungswert default 'right' ‚Äî nutze data-direction wenn vorhanden
        const direction = link.dataset.direction || 'right';

        startTransitionAndNavigate(href, direction);
      });
    });

  })();
  </script>

  <!-- üì∞ News-Slider -->
  <script>
    const newsList = [
      { text: "Projekt gestartet ‚Äì mehr Inhalte folgen bald!", link: "#" },
      { text: "BTC-Watcher jetzt mit Alias-Funktion", link: "https://example.com/alias" },
      { text: "Telegram-Benachrichtigungen live", link: "https://example.com/telegram" },
      { text: "Wer hat an der Uhr gedreht", link: "https://example.com/Uhr" },
      { text: "Donate Website", link: "hiddenpaper53@getalby.com" }
    ];

    let current = 0;
    const contentEl = document.getElementById("news-content");
    const prevBtn = document.getElementById("prev-news");
    const nextBtn = document.getElementById("next-news");
    const cycleInterval = 5000;
    let autoPlay;

    function renderNews() {
      contentEl.classList.add("fade-out");
      setTimeout(() => {
        const item = newsList[current];
        contentEl.innerHTML = `<a href="${item.link}" target="_blank">${item.text}</a>`;
        contentEl.classList.remove("fade-out");
      }, 500);
    }

    prevBtn.addEventListener("click", () => {
      current = (current - 1 + newsList.length) % newsList.length;
      renderNews();
      resetAutoPlay();
    });

    nextBtn.addEventListener("click", () => {
      current = (current + 1) % newsList.length;
      renderNews();
      resetAutoPlay();
    });

    function startAutoPlay() {
      autoPlay = setInterval(() => {
        current = (current + 1) % newsList.length;
        renderNews();
      }, cycleInterval);
    }

    function resetAutoPlay() {
      clearInterval(autoPlay);
      startAutoPlay();
    }

    const newsContainer = document.querySelector(".news-container");
    newsContainer.addEventListener("mouseenter", () => clearInterval(autoPlay));
    newsContainer.addEventListener("mouseleave", () => startAutoPlay());

    window.addEventListener("DOMContentLoaded", () => {
      renderNews();
      startAutoPlay();
    });
  </script>

</body>
</html>
