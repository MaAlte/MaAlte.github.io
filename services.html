<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <link href="https://fonts.googleapis.com/css2?family=Allerta+Stencil&display=swap" rel="stylesheet" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Services</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <header class="top-bar">
    <a href="index.html" data-direction="left" class="logo" title="Zur Startseite">
    <img src="img/BlackHoleBTC-DOLLAR.jpg" alt="MaAlte81 Logo" class="logo" />
    </a>
    <div class="site-title">MaAlte81</div>
  </header>

  <div class="glass-container">
    <h1>Services</h1>

    <!-- <div class="content">
      <p>Hier findest du eine √úbersicht meiner aktuellen Projekte, Tools und technischen Services. Inhalte folgen bald.</p>
    </div> -->

    <div class="content">
      <h1>BTC Ticker</h1> <br>

      <h2>BLOCKCLOCK‚Ñ¢ Live</h2>
      <div id="moscowTime">Moscow Time: ...</div>
      <div id="btcPrice">BTC Preis: ...</div>
      <div id="blockHeight">Blockh√∂he: ...</div>
      <div id="lastUpdated">Letzte Aktualisierung: ...</div> <br>
      <div id="Donate">
        <p>
          Spenden via Lightning:
          <a href="lightning:richesttea639@walletofsatoshi.com">richesttea639@walletofsatoshi.com</a>
        </p>
      </div>  
     </div>

      <script>
        let secondsSinceUpdate = 0;
        let updateInterval = 10000; // 10 Sekunden

        async function getBTCPrice() {
          try {
            const res = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd");
            const data = await res.json();
            return parseFloat(data.bitcoin.usd);
          } catch (e) {
            return null;
          }
        }

        async function getBlockHeight() {
          try {
            const res = await fetch("https://mempool.space/api/blocks/tip/height");
            const height = await res.text();
            return height;
          } catch (e) {
            return "Offline";
          }
        }

        function calculateSatsPerDollar(btcPrice) {
          const sats = 100000000 / btcPrice;
          return Math.floor(sats).toLocaleString("de-DE");
        }

        async function updateWidget() {
          const btcPrice = await getBTCPrice();
          const blockHeight = await getBlockHeight();
          const satsPerDollar = btcPrice ? calculateSatsPerDollar(btcPrice) : "Offline";

          document.getElementById("moscowTime").textContent = "Moscow Time: " + satsPerDollar + " Sats/$";
          document.getElementById("btcPrice").textContent = "BTC Preis: $" + (btcPrice ? btcPrice.toFixed(2) : "Offline");
          document.getElementById("blockHeight").textContent = "Blockh√∂he: " + blockHeight;

          secondsSinceUpdate = 0;
          document.getElementById("lastUpdated").textContent = "Letzte Aktualisierung: vor 0 Sekunden";
        }

        setInterval(updateWidget, updateInterval);

        setInterval(() => {
          secondsSinceUpdate++;
          document.getElementById("lastUpdated").textContent = "Letzte Aktualisierung: vor " + secondsSinceUpdate + " Sekunden";
        }, 1000);

        updateWidget();
      </script>
    <div class="content">


    <nav>
      <a href="index.html" data-direction="left">Home</a>
      <a href="services.html" data-direction="left">Services</a>
      <a href="kontakt.html" data-direction="right">Kontakt</a>
      <a href="impressum.html" data-direction="right">Impressum</a>
    </nav>

    <div class="page-transition" id="page-transition"></div>
    
    <footer id="last-modified"></footer>
  </div>

  <!-- Seitenstart-Animation: in jede Seite -->
  <script>
  function handlePageEnter() {
    const overlay = document.getElementById('page-transition');
    const container = document.querySelector('.glass-container');
    const direction = sessionStorage.getItem('transitionDirection');

    if (sessionStorage.getItem('transitioning') === 'true') {
      // Overlay ausblenden (falls noch aktiv)
      overlay?.classList.remove('active');

      // Setze passende enter-Klasse abh√§ngig von Richtung
      if (direction === 'left') {
        container?.classList.add('page-enter-left');
      } else {
        container?.classList.add('page-enter-right');
      }

      // Entferne rotate-Klassen erst nach der enter-Animation
      setTimeout(() => {
        container?.classList.remove('rotate-left', 'rotate-right');
        sessionStorage.removeItem('transitioning');
        sessionStorage.removeItem('transitionDirection');
      }, 700); // passt zu deinen CSS-Durations
    }
  }

  window.addEventListener('DOMContentLoaded', handlePageEnter);
  window.addEventListener('pageshow', handlePageEnter);
  </script>


  <!-- üìÖ Letzte √Ñnderung anzeigen -->
  <script>
    document.getElementById('last-modified').textContent =
      'Letzte √Ñnderung: ' + document.lastModified;
  </script>

  <!-- üß≠ Robust: Navigation + Rotation + Overlay mit Repaint + transitionend + Fallback -->
  <script>
  (function () {
    const container = document.querySelector('.glass-container');
    const navLinks = document.querySelectorAll('nav a');
    const transitionOverlay = document.getElementById('page-transition');

    if (!container || !transitionOverlay || navLinks.length === 0) return;

    let navigating = false; // sch√ºtzt vor Mehrfachausl√∂sung

    // Utility: force reflow
    function forceReflow(el) {
      void el.offsetWidth;
    }

    // Start transition sequence und navigiere, wenn Overlay-Transition beendet oder Fallback l√§uft
    function startTransitionAndNavigate(href, direction) {
      if (navigating) return;
      navigating = true;

      const rotateClass = `rotate-${direction}`;

      // 1) Entferne vorherige Klassen (sicherstellen, dass Neu-Setzen wirkt)
      container.classList.remove('rotate-left', 'rotate-right', 'page-enter-left', 'page-enter-right', 'page-enter');
      transitionOverlay.classList.remove('active');

      // 2) Erzwinge Reflow, damit Entfernen gerendert wird
      forceReflow(container);
      forceReflow(transitionOverlay);

      // 3) Jetzt erst Klassen setzen, Overlay aktivieren
      container.classList.add(rotateClass);
      transitionOverlay.classList.add('active');

      // 4) Markieren und Richtung speichern f√ºr die eingehende Seite
      sessionStorage.setItem('transitioning', 'true');
      sessionStorage.setItem('transitionDirection', direction);

      // 5) Einmaliger transitionend-Handler auf dem Overlay
      const onEnd = (ev) => {
        // optional: pr√ºfe propertyName wenn du mehrere Transitionen hast
        // if (ev.propertyName !== 'opacity' && ev.propertyName !== 'transform') return;
        cleanupAndNavigate();
      };

      // Fallback nach maximal 1s (falls transitionend nicht feuert)
      const fallback = setTimeout(cleanupAndNavigate, 1000);

      function cleanupAndNavigate() {
        transitionOverlay.removeEventListener('transitionend', onEnd);
        clearTimeout(fallback);
        // kleine Verz√∂gerung vor dem eigentlichen Location-Wechsel, damit der browser final rendern kann
        requestAnimationFrame(() => {
          setTimeout(() => {
            window.location.href = href;
          }, 20);
        });
      }

      transitionOverlay.addEventListener('transitionend', onEnd, { once: true });

      // Safety: falls overlay hat keine transition (dev-Fehler), trigger fallback sofort
      // (keine weitere Aktion erforderlich hier)
    }

    // Attach handler an alle Links
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        // interne anchor- oder externe link-behandlung: nur eigene htmls
        const href = link.getAttribute('href');
        if (!href) return;
        // Wenn Link auf dieselbe Seite zeigt, verhindere unn√∂tigen reload
        if (href === location.pathname.split('/').pop() || href === window.location.pathname) {
          // erlauben normalem Verhalten (kein Seitenwechsel) oder einfach nichts tun
          // wir verhindern reload, damit page-enter/exit nicht st√∂ren
          e.preventDefault();
          return;
        }

        e.preventDefault();

        // Richtungswert default 'right' ‚Äî nutze data-direction wenn vorhanden
        const direction = link.dataset.direction || 'right';

        startTransitionAndNavigate(href, direction);
      });
    });

  })();
  </script>

</body>
</html>
